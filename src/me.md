# Linux (deannven)
### Part 1. Установка ОС
1. Скачиваю с официального сайта VirtualBox (https://releases.ubuntu.com/focal/)
2. Устанавливаю VirtualBox
3. Скачал образ https://ubuntu.com/download/server
4. Следовал гуиду https://internet-lab.ru/install_ubuntu_server_20_04_lts

### Part 2. Создание пользователя
1. Добавляем ivan: 
`sudo adduser ivan`
логин ivan, 
пароль 111.

2. Даем доступ к группе adm:
`sudo usermod -a -G adm ivan`

3. Смотрим какие группы есть у ivan:
    
    `groups ivan`

    Скриншот ниже:

    ![part_2.1](src/images/part_2.1.PNG)

4. Смотрим вывод команды согласно заданию part 2:
    
    `cat /etc/passwd`
    
    Скриншот ниже:
    
    ![part_2.2](src/images/part_2.2.PNG)

### Part 3. Настройка сети ОС
1. Так как изначальное имя хоста den, надо сменить имя на user-1:
    
    Смотрим текущее имя:
    `uname -n`
    
    Меняем его:
    `sudo hostnamectl set-hostname user-1`
    
    Смотрим изменения:
    `uname -n`

2. Изначально UTC +00, надо +03

    Изучаем и находим нужный нам UTC (это Europe/Moscow):
    `timedatectl list-timezones`
    
    Изменяем на нужный: 
    `sudo timedatectl set-timezone Europe/Moscow`
    
    Смотрим изменения:
    `timedatectl`

3. Вывести названия сетевых интерфейсов можно вывести при помощи ip:

    `ip link show`

    `ip address show`
    
    Скриншот ниже:
    
    ![part_3.1](src/images/part_3.1.PNG)

    Сетевой интерфейс lo в Ubuntu (Loopback) используется для обеспечения коммуникации между процессами внутри компьютера, не требуя физического    соединения с другими устройствами в сети. Это позволяет многим системным и сетевым приложениям, таким как базы данных, серверы и сетевые службы, работать без фактического подключения к сети. Таким образом, сетевой интерфейс lo является важным компонентом для правильной работы многих системных и сетевых функций в Ubuntu.

4. ip адрес устройства можно получить при помощи следующих команд:
    `hostname -I`
    
    или же:

    `ip a`
    
    `ip address`
    
    `ip addr`
    
    Все это одно.
    На скришоте ниже выделен ip адрес устройства. /24 - это маска подсети, 255.255.255.0

    ![part_3.2](src/images/part_3.2.PNG)

    DHCP (Dynamic Host Configuration Protocol) - это сетевой протокол, который позволяет автоматически назначать IP-адреса и другие настройки сети устройствам, которые подключаются к сети.

5. Внешний ip-адрес шлюза:
    
    `wget -O - -q icanhazip.com`
    
    Или же посмотреть на сайте: https://yoip.ru/
    
    Скриншот ниже 
    
    ![part_3.3](src/images/part_3.3.PNG)

    ip-адрес по умолчанию:
    `ip route`
    
    10.0.2.2
    
    Скриншот ниже
    
    ![part_3.4](src/images/part_3.4.PNG)

    Настройка статического ip адреса:
    `sudo vim /etc/cloud/cloud.cfg.d/subiquity-disable-cloudinit-networking.cfg`
    
    Network надо установить disabled.
    У меня уже было disabled, просто вышел в vim.
    
    `sudo vim /etc/netplan/00-installer-config.yaml`
    
    Выставляем параметор dhcp4: false. И дополнительно требуется прописать addresses, gateway4, nameservers
    Где gateway4 - задаёт адрес, через который наш компьютер сможет получить доступ в интернет;
    Где addresses - параметр ожидает список IP-адресов, которые нужно присвоить нашей сетевой карте, у нас только один адрес, однако, передавать его надо тоже в формате списка, иначе будет ошибка. В конце адреса указывается префикс маски - /24, который отвечает маске сети 255.255.255.0. Вы можете указать и другую маску, но только с помощью префикса, отдельного параметра для этого нет.
    nameservers - это IP-адреса DNS-серверов, к которым будет обращаться система для разрешения доменных имен на IP-адреса.
    Нажимаем ESC вписываем :wq чтобы выйти с записью.
    Скриншот ниже
    
    ![part_3.5](src/images/part_3.5.PNG)

    Применяем новые настройки Netplan командой ниже:
    `sudo netplan apply`
    
    Проверяем отклик сайта ya.ru и 8.8.8.8 (так как у меня нет VPN и зная https://habr.com/ru/news/t/718770/ , у меня 1.1.1.1 не пинговался через ноут, но на маке в школе пинговаться будет):
    
    `ping -c 4 ya.ru`

    `ping -c 4 8.8.8.8`

    Скриншот ниже
    
    ![part_3.6](src/images/part_3.6.PNG)

### Part 4. Обновление ОС
1. Первым делом, нам необходимо выполнить обновление репозиториев ubuntu, для этого используется такая команда обновления ubuntu:
`sudo apt update`
2. Далее обновить:
`sudo apt full-upgrade`

Скриншоты ниже

![part_3.7](src/images/part_3.7.PNG)

![Part_3.8](src/images/Part_3.8.PNG)

### Part 5. Использование команды sudo
1. Истинное назначение команды sudo:
    Sudo (Super User Do) является утилитой в операционной системе Ubuntu, которая позволяет обычному пользователю выполнять задачи, которые обычно могут выполняться только суперпользователем (root). 

    Правильное использование утилиты sudo - это предоставление временного доступа к командам суперпользователя без необходимости входа в систему от его имени. В отличие от постоянного входа в систему от имени суперпользователя, использование sudo позволяет ограничить привилегии пользователя только на время выполнения определенных задач.

    Иными словами, sudo предназначен для безопасного и ответственного выполнения задач с повышенными привилегиями в Ubuntu, с учетом того, что суперпользователь имеет неограниченный доступ к системе и его действия могут негативно повлиять на работу системы, если они выполняются неосторожно или некорректно.

2. Даем рууд права: 
    `sudo usermod -aG sudo ivan`
    
    Скриншот ниже
    
    ![part_5.1](src/images/part_5.1.PNG)

3. Заходим за ivan:
    `su - ivan`

4. Меняем hostname  от имени ivan:
    `sudo hostnamectl set-hostname user-ivan`
    
    `uname -n`
    
    Скриншот ниже
    
    ![part_5.2](src/images/part_5.2.PNG)


### Part 6. Установка и настройка службы времени
1. Вывести время, часового пояса, в котором вы сейчас находитесь:
    `timedatectl`

2. Вывод следующей команды должен содержать NTPSynchronized=yes: timedatectl show

    Скриншот ниже

    ![part_6.1](src/images/part_6.1.PNG)

### Part 7. Установка и использование текстовых редакторов
#### Часть 1: Используя каждый из трех выбранных редакторов, создайте файл test_X.txt, где X -- название редактора, в котором создан файл. Напишите в нём свой никнейм, закройте файл с сохранением изменений.
1. VIM:

    Так как у меня стоял vim, я его не устанавливал, создаю файл через vim и вписываю свой никней с сохранением файла:
    `vim test_vim.txt`
    
    a

    deannven
    
    ESC
    
    :wq

    Скриншот ниже

    ![part_7.1](src/images/part_7.1.PNG)

2. NANO:

    `nano test_nano.txt`
    
    deannven
    
    CTRL+X
    
    Y
    
    Скриншот ниже
    
    ![part_7.2](src/images/part_7.2.PNG)

3. JOE:
    Так как у меня не стоит этот редактор, требуется установить: `sudo apt install joe`
    
    Далее создаем файл:
    `joe test_joe.txt`

    deannven
    
    CTRL+K Q

    Скриншот ниже
    
    ![part_7.3](src/images/part_7.3.PNG)

#### Часть 2: Используя каждый из трех выбранных редакторов, откройте файл на редактирование, отредактируйте файл, заменив никнейм на строку "21 School 21", закройте файл без сохранения изменений.
1. VIM:
    `vim test_vim.txt`
    
    :q!
    
    Скриншот ниже
    
    ![part_7.4](src/images/part_7.4.PNG)

2. NANO:

    `nano test_nano.txt`
    
    CTRL+X
    
    N

    Скриншот ниже
    
    ![part_7.5](src/images/part_7.5.PNG)

3. JOE:
    
    `joe test_joe.txt`
    
    CTRL+С
    
    Скриншот ниже
    
    ![part_7.6](src/images/part_7.6.PNG)

#### Часть 3: Используя каждый из трех выбранных редакторов, отредактируйте файл ещё раз (по аналогии с предыдущим пунктом), а затем освойте функции поиска по содержимому файла (слово) и замены слова на любое другое.
1. VIM: 

    `vim test_vim.txt`
    
    :%s/\<foo\>/bar/g
    
    Скриншот ниже
    
    ![part_7.7](src/images/part_7.7.PNG)

Полезный гайд:
https://routerus.com/vim-find-replace/#:~:text=%D0%92%20Vim%20%D0%B2%D1%8B%20%D0%BC%D0%BE%D0%B6%D0%B5%D1%82%D0%B5%20%D0%BD%D0%B0%D0%B9%D1%82%D0%B8,%D0%BF%D1%80%D0%BE%D1%81%D1%82%D0%BE%20%D0%BD%D0%B0%D0%B6%D0%BC%D0%B8%D1%82%D0%B5%20%D0%BA%D0%BB%D0%B0%D0%B2%D0%B8%D1%88%D1%83%20%C2%ABEsc%C2%BB.

2. NANO:
    
    Возможно сделать таким образом: 
    
    `nano test_nano.txt`
    
    CTRL+\
    
    ven
    
    KRA-KRA

    Заменит ven на KRA-KRA, аналог CTRL+\ будет Alt+R

    Скриншот ниже
    
    ![part_7.8](src/images/part_7.8.PNG)

3. JOE:

    `joe test_joe.txt`
    
    CTRL+K F
    
    ven
    
    r
    
    KRA-KRA
    
    Скриншот ниже
    
    ![part_7.9](src/images/part_7.9.PNG)

### Part 8. Установка и базовая настройка сервиса SSHD
1. Установить службу SSHd:

    `sudo apt-get install ssh`

    `sudo apt install openssh-server`

2. Добавить автостарт службы при загрузке системы:
    
    `sudo systemctl enable sshd`

    Посмотрим работает ли: 
    
    `systemctl status sshd`

    Скриншот ниже

    ![part_8.1](src/images/part_8.1.PNG)

3. Перенастроить службу SSHd на порт 2022:
    
    `sudo vim /etc/ssh/sshd_config`

    Скриншот ниже

    ![part_8.2](src/images/part_8.2.PNG)

    Перезапускаем SSH-сервер:
    
    `systemctl restart sshd`

    Скриншот ниже
    
    ![part_8.3](src/images/part_8.3.PNG)

4. Вывод команды netstat -tan должен содержать:
    
    Так как этой команды нет, пришлось установить:
    
    `sudo apt install net-tools`

    Скриншот ниже
    
    ![part_8.4](src/images/part_8.4.PNG)

5. В отчёте объяснить значение ключей -tan, значение каждого столбца вывода, значение 0.0.0.0:

    Команда netstat -tan отображает список всех открытых сокетов на хосте, с указанием их протоколов, адресов, портов и текущих состояний. Расшифровка поля вывода:

    - Proto - протокол транспортного уровня, используемый сокетом;
    - Local Address - локальный IP-адрес и порт сокета, на котором хост ожидает входящие соединения;
    - Foreign Address - удаленный IP-адрес и порт сокета, к которому есть активное соединение;
    - State - текущее состояние сокета.

    Значения поля State могут включать:

    - LISTEN - сокет открыт и ждет входящих подключений;
    - ESTABLISHED - установлено активное соединение с удаленной стороной;
    - TIME_WAIT - сокет в ожидании завершения соединения;
    - CLOSE_WAIT - локальное приложение получило запрос на закрытие соединения, но удаленная сторона еще не закрыла свое соединение;
    - SYN_SENT - был отправлен запрос на установление соединения, но еще не получен ответ;
    - SYN_RECV - получен запрос на установление соединения, и ожидается ответ на этот запрос;
    - FIN_WAIT1 - одна сторона отправила запрос на закрытие соединения, и ждет, пока другая сторона отправит подтверждение;
    - FIN_WAIT2 - обе стороны отправили запросы на закрытие соединения, и взаимодействуют в преддверии закрытия соединения.

    В общем, вывод этой команды может помочь определить, какие сетевые соединения установлены на хосте, какие порты открыты, и какие приложения и процессы могут использовать эти соединения.

    В выводе команды netstat -tan столбцы Recv-Q и Send-Q обозначают размеры очередей приёма и передачи данных (receive queue и send queue) для соответствующих сокетов.

    - Recv-Q - количество байтов, которые находятся в буфере на приём данных для данного сокета. Если это число больше нуля, значит, приложение должно прочитать данные из очереди, чтобы освободить место для более новых данных.
    - Send-Q - количество байтов, которые находятся в буфере на передачу данных для данного сокета. Если это число больше нуля, значит, приложение уже отправило данные, но они еще не были подтверждены на удаленной стороне и не удалены из очереди отправки. При этом, если очередь отправки заполняется слишком быстро, это может указывать на неравномерное распределение загрузки в сети.

    Значения в этих столбцах могут помочь определить заторы в сетевых соединениях (например, на маршрутизаторе или по какой-то причине на удаленной стороне) и указать на потенциальные проблемы сетевой производительности. Если размеры очередей достигают максимально допустимой величины, то это может привести к потери данных, задержкам в доставке и прочим проблемам работы сети.

### Part 9. Установка и использование утилит top, htop
#### По выводу команды top определить и написать в отчёте:
1. uptime:

    В выводе команды top в Ubuntu используется столбец uptime, который отображает время, прошедшее с момента последней перезагрузки системы в формате days:hours:minutes:seconds.

    Например, если у вас в выводе команды uptime отображается 10:05:30:40, то это означает, что система работает уже более 10 дней, 5 часов, 30 минут и 40 секунд.

    Информация в столбце uptime может быть полезна для определения, насколько давно была выполнена перезагрузка системы. Это может быть важно при анализе ее производительности и поиске возможных проблем. Например, если система работает уже несколько дней, то возможно, что происходит утечка памяти или некоторые процессы потребляют слишком много ресурсов, что замедляет работу системы.

2. количество авторизованных пользователей:
    
    В выводе команды top в Ubuntu поле users отображает количество авторизованных пользователей на системе. Это поле показывает, сколько пользователей в данный момент работают в системе.

    Например, если в поле users отображается число 2, то это означает, что в системе находятся два авторизованных пользователя в данный момент. Если в системе присутствует только один пользователь, то на месте этого поля отображается 1.

    Информация о количестве авторизованных пользователей может быть полезна для администратора системы, чтобы лучше понимать, как используются ресурсы системы, и быстро определять возможные проблемы (например, когда слишком много пользователей пытаются одновременно выполнить сложные задачи).

    В целом, поле users в команде top может помочь в контроле нагрузки на систему и обеспечить более эффективное использование ее ресурсов.

3. общую загрузку системы:

    В выводе команды top в Ubuntu столбец load average, расположенный в верхней части, показывает общую загрузку системы в течение определенного периода времени. Обычно, этот показатель отображается на 1, 5 и 15 минутах.

    Число, отображаемое в столбце load average, представляет собой среднее количество процессов, которые занимаются выполнением задач в данный момент, и ожидают своей очереди на процессорном ядре за последние 1, 5 и 15 минут соответственно. В общем случае, чем выше значение load average, тем больше нагрузка на систему.

    Например, если load average равно 0,3, 0,5 и 0,8 соответственно, то это означает, что в среднем за последние 1, 5 и 15 минут было выполняемо 0,3, 0,5 и 0,8 процессов соответственно.

    Информация в столбце load average может быть полезной для администратора системы при анализе производительности системы и определении ее возможной проблемы.

    Обычно, если значения load average превышает количество доступных процессорных ядер, то это сигнализирует о недостатке ресурсов системы. Поэтому, для поддержания плавной работы системы рекомендуется контролировать значения этого столбца и, если необходимо, оптимизировать работу процессов.

4. общее количество процессов:

    Tasks в команде top отображает общее количество процессов на системе.
    Running показывает количество процессов, которые находятся в состоянии выполнения в данный момент.
    Stopped - это количество процессов, которые были остановлены, часто из-за использования сигнала пользователем, такого как Ctrl+Z.
    Zombie - это процессы, которые уже завершены, но все еще удерживают системные ресурсы. Они доступны только для чтения и не могут быть завершены нормальным образом. Такие процессы обычно возникают, когда родительский процесс не удаляет дочерние процессы вовремя.

5. Загрузку cpu:

    - CPU(s) - количество ядер, используемых процессами (на многоядерных системах).
    - us - (user) время, затраченное процессором на выполнение пользовательской работы (считается для всех процессов пользователя).
    - sy - (system) время, затраченное процессором на выполнение системных задач (чаще всего это ядро операционной системы, драйверы, настройка аппаратных устройств).
    - ni - (nice) время, затраченное процессором на выполнение задач с приоритетом niceness (аффинитет).
    - id - (idle) процент времени, в течение которого CPU был простаивал, то есть не занимался вычислениями какой-либо работы, ожидая получения новой задачи.
    - wa - (iowait) процент времени, в течение которого процессор ожидал выполнении ввода/вывода (IO).
    - hi - (hardware interrupt) процент времени, в течение которого процессор занимался обработкой аппаратных прерываний.
    - si - (software interrupt) процент времени, в течение которого процессор занимался обработкой программных прерываний (вызванных системой или ядром).
    - st - (stolen time) процент времени, когда гипервизор типа KVM "украл" циклы процессора из виртуальной машины для своих собственных целей.
    Все значения в процентах и могут варьироваться в зависимости от нагрузки на систему и ее конфигурации.

6. Загрузку памяти:

    В выводе команды top в Ubuntu столбец MiB Mem показывает общий объем доступной оперативной памяти на компьютере.

    Столбец free показывает количество свободной оперативной памяти в текущий момент, которое может быть использовано для запуска новых процессов и приложений.

    Столбец used показывает количество оперативной памяти, которое уже используется в данный момент процессами и приложениями.

    Столбец buff/cache показывает объем памяти, который используется системой для кэширования данных для ускорения доступа к ним.

    Например, если столбец MiB Mem показывает общий объем оперативной памяти в размере 8001, а столбцы free, used и buff/cache показывают соответственно 500, 7000 и 501, то в системе имеется 500 MiB свободной оперативной памяти, 7000 MiB оперативной памяти уже используется процессами и приложениями, а 501 MiB используются системой для кэширования данных.

    Информация в столбцах free, used и buff/cache может быть полезна для администратора системы при анализе состояния системы и определении возможных проблем с памятью. Если свободной оперативной памяти не хватает для запуска новых процессов, это может привести к тому, что система перегружается и работает медленно. В таких случаях может быть необходимо закрыть некоторые приложения или процессы, чтобы освободить оперативную память для новых задач.

    В выводе команды top в Ubuntu столбец MiB Swap показывает размер раздела подкачки (swap), которое используется для хранения служебных данных и временных файлов в оперативной памяти на жестком диске, когда свободной оперативной памяти не хватает.

    Столбец free показывает количество свободной оперативной памяти в данный момент.

    Столбец used показывает количество оперативной памяти, которое уже используется в данный момент процессами и приложениями.

    Столбец avail Mem показывает оставшуюся доступную оперативную память, которая может быть использована процессами и приложениями.

    Например, если столбец MiB Swap показывает размер раздела подкачки в размере 1024, а столбцы free, used и avail Mem показывают соответственно 500, 7000 и 4000, то в системе имеется 500 MiB свободной оперативной памяти, 7000 MiB оперативной памяти уже используется процессами и приложениями, а 4000 MiB доступной оперативной памяти.

    Информация в столбцах free, used, avail Mem и MiB Swap может быть полезна для администратора системы при анализе состояния системы и определении возможных проблем с памятью. Если система постоянно использует раздел подкачки, это может привести к замедлению работы системы, так как работа с ним медленнее, чем с оперативной памятью. В таком случае, может быть необходимо увеличить объем оперативной памяти или освободить ее от ненужных процессов и приложений, чтобы уменьшить использование раздела подкачки.

7. pid процесса занимающего больше всего памяти: 

    `top -o %MEM -n 1`
    
    Флаг -o отвечает за сортировку по полю %MEM
    
    Флаг -n количество циклов обновления данных, после которых надо закрыть программу
    
    Скриншот ниже
    
    ![part_9.1](src/images/part_9.1.PNG)

8. pid процесса, занимающего больше всего процессорного времени:
    
    `top -o %CPU -n 1`

#### В отчёт вставить скрин с выводом команды htop:

1. Отсортировать по PID:

    `htop -s PID`
    
    Скриншот ниже

    ![part_9.2](src/images/part_9.2.PNG)

2. Отсортировать по PERCENT_CPU: 

    `htop -s PERCENT_CPU`

    Скриншот ниже

    ![part_9.3](src/images/part_9.3.PNG)

3. Отсортировать по PERCENT_MEM:
    
    `htop -s PERCENT_MEM`

    Скриншот ниже

    ![part_9.4](src/images/part_9.4.PNG)

4. Отсортировать по TIME:

    `htop -s TIME`

    Скриншот ниже
    
    ![part_9.5](src/images/part_9.5.PNG)

5. Отфильтрованному для процесса sshd:

    Запустите htop с помощью команды htop.
    Нажмите клавишу F4 и вбиваем, что надо, у нас это sshd.
    
    Скриншот ниже

    ![part_9.6](src/images/part_9.6.PNG)

6. C процессом syslog, найденным, используя поиск:
    
    ![part_9.7](src/images/part_9.7.PNG)

7. C добавленным выводом hostname, clock и uptime:
    
    Нажимаем клавишу F2.
    - Для clock.
    
        Скриншот ниже
    
        ![part_9.8](src/images/part_9.8.PNG)

    - Для uptime. Настройка там же, где и clock.

    - Для hostname. Там же.

    Все готово:
    
    Скриншот ниже
    
    ![part_9.9](src/images/part_9.8.PNG)

### Part 10. Использование утилиты fdisk
Я записал результат команды в txt файл. 

`sudo fdisk -l > disk.txt`

`vim disk.txt`
 
1. Название жесткого диска, размер и количество секторов:

    `sudo fdisk -l -u`

    Скриншот ниже

    ![part_10.1](src/images/part_10.1.PNG)

3. Размер swap: 

    `free -h`

    Скриншот ниже
    
    ![part_10.2](src/images/part_10.2.PNG)

### Part 11. Использование утилиты df
#### Запустить команду df: 
Скриншот ниже

![part_11.1](src/images/part_11.1.PNG)

1. Размер раздела: Поле 1K-blocks (8408452).
2. Размер занятого пространства: Поле Used (4272980).
3. Размер свободного пространства: Поле Available (3686756).
4. Процент использования: Use% (54%).
5. Единица измерения в килобайтах.

#### Запустить команду df -Th:

1. Размер раздела: Поле Size (8,1 ГБ).
2. Размер занятого пространства: Поле Used (4,1 ГБ).
3. Размер свободного пространства: Поле Available (3,6 ГБ).
4. Процент использования: Use% (54%).
5. Единица измерения в Гб.

### Part 12. Использование утилиты du.

1. Размер папки /home:
    
    `du -h /home`
    
    Скриншот ниже
    
    ![part_12.1](src/images/part_12.1.PNG)

2. Размер папки /var: 
    
    `du -h /var`

    Скриншот ниже
    
    ![part_12.2](src/images/part_12.2.PNG)

3. Размер папки /var/log:
    
    `du -h /var/log` 
    
    Скриншот ниже
    
    ![part_12.3](src/images/part_12.3.PNG)

4. Вывести размер всего содержимого в /var/log:

    `sudo -hc /var/log/*`
    
    Скриншот ниже
    
    ![part_12.4](src/images/part_12.4.PNG)

### Part 13. Установка и использование утилиты ncdu

1. Размер папки /home:
    
    ![part_13.1](src/images/part_13.1.PNG)

2. Размер папки /var:
    
    ![part_13.2](src/images/part_13.2.PNG)

3. Размер папки /var/log:

    ![part_13.3](src/images/part_13.3.PNG)

### Part 14. Работа с системными журналами

1. /var/log/dmesg:

    ![part_14.1](src/images/part_14.1.PNG)

2. /var/log/syslog:

    ![part_14.2](src/images/part_14.2.PNG)

3. /var/log/auth.log:

    ![part_14.3](src/images/part_14.3.PNG)

4. Написать в отчёте время последней успешной авторизации, имя пользователя и метод входа в систему: 
    10 марта в 09:08

    `grep login:session -n /var/log/auth.log | tail -n 1`

    Скриншот ниже
    
    ![part_14.4](src/images/part_14.4.PNG)

5. Перезапустить службу SSHd:

    `systemctl restart sshd`

6. Вставить в отчёт скрин с сообщением о рестарте службы (искать в логах):
    
    ![part_14.5](src/images/part_14.5.PNG)

#### Part 15. Использование планировщика заданий CRON
##### Используя планировщик заданий, запустите команду uptime через каждые 2 минуты:
Создаем sh файл myuptime.sh:

`vim myuptime.sh`

В нем требуется применять команду uptime и записывать в лог: 

`#!/bin/bash`
`uptime >> /home/ivan/uptime.log`

Так же не забываем дать права:

`chmod +x myuptime.sh`

Откройте планировщик задач Cron, выполнив команду:

`crontab -e`

Добавьте следующую строку в конец файла:

`*/2 * * * * /bin/bash /home/ivan/myuptime.sh`

Скриншот ниже

![part_15.1](src/images/part_15.1.PNG)

В журнале это выглядит так: 

![part_15.2](src/images/part_15.2.PNG)

Вывести на экран список текущих заданий для CRON:

![part_15.3](src/images/part_15.3.PNG)

##### Удалите все задания из планировщика заданий:

`crontab -r`

Скриншот ниже

![part_15.4](src/images/part_15.4.PNG)